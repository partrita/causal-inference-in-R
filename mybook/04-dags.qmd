# 인과적 질문을 DAG로 표현하기 {#sec-dags}

{{< include 00-setup.qmd >}}

```{r}
#| echo: false
# TODO: 첫 번째 판이 완료되면 제거
status("complete")
```

## 인과적 가정 시각화하기

> 우리가 어떤 것을 그 자체로 골라내려고 할 때, 우리는 그것이 우주의 모든 것에 깨뜨릴 수 없는 천 개의 보이지 않는 끈으로 단단히 묶여 있음을 발견한다. -- 존 뮤어

**인과 다이어그램**은 답하려는 질문의 인과 구조에 대한 가정을 시각화하는 도구입니다.
무작위 실험에서 인과 구조는 매우 간단합니다.
결과의 원인은 많을 수 있지만 노출의 유일한 원인은 무작위화 과정 자체입니다(그렇게 되기를 바랍니다!).
그러나 많은 비무작위 환경에서는 질문의 구조가 복잡한 인과 관계의 그물일 수 있습니다.
인과 다이어그램은 이 구조가 어떻게 생겼다고 생각하는지 전달하는 데 도움이 됩니다.
인과 구조가 무엇이라고 생각하는지에 대해 공개하는 것 외에도 인과 다이어그램은 관찰 데이터를 사용하더라도 편향되지 않은 인과 효과를 추정하는 방법을 식별할 수 있는 놀라운 수학적 속성을 가지고 있습니다. 즉, 올바르게 지정되면 교환 가능성을 달성하는 데 도움이 됩니다.

인과 다이어그램은 또한 점점 더 일반화되고 있습니다.
응용 건강 연구 논문의 인과 다이어그램 검토로 수집된 데이터는 시간 경과에 따른 사용량의 급격한 증가를 보여줍니다 [@Tennant2021].

```{r}
#| label: fig-dag-usage
#| echo: false
#| warning: false
#| fig-cap: "시간 경과에 따른 건강 연구 논문의 인과 다이어그램 사용 비율."
dag_data <- readxl::read_xlsx(here::here("data", "dag_data.xlsx"))

dag_data <- dag_data |>
  separate(
    dag_number,
    into = c("dag_number", "dag_location"),
    convert = TRUE,
    extra = "merge"
  ) |>
  separate(
    consistent_direction,
    into = c("consistent_direction", "dag_ordering"),
    extra = "merge"
  ) |>
  separate(
    report_adjset,
    into = c("report_adjset", "report_adjset_loc"),
    extra = "merge"
  ) |>
  mutate(
    year = str_extract(citation, "\\d{4}") |> as.integer(),
    used_dag = !is.na(nodes),
    reported_estimand = !str_detect(report_estimand, "Not reported")
  )

dag_data |>
  count(year, used_dag) |>
  mutate(pct = n / sum(n)) |>
  filter(used_dag, year < max(year)) |>
  ggplot(aes(year, pct)) +
  geom_line(color = "#0072B2", linewidth = .9) +
  scale_y_continuous(
    name = "논문 비율",
    labels = scales::label_percent()
  )
```

우리가 사용하는 인과 다이어그램 유형은 **방향성 비순환 그래프(DAG)**라고도 합니다[^04-dags-1].
이러한 그래프는 특정 방향으로 향하는 화살표를 포함하기 때문에 방향성이 있습니다.
원이 없기 때문에 비순환적입니다. 예를 들어 변수가 자신을 유발할 수는 없습니다.
DAG는 다양한 문제에 사용되지만 우리는 특히 **인과적 DAG**에 관심이 있습니다.
이러한 DAG 클래스는 질문의 인과 구조 모델이기 때문에 때때로 **구조적 인과 모델(SCM)**이라고 불립니다 [@hernan2021; @Pearl_Glymour_Jewell_2021].

[^04-dags-1]: DAG의 중요하지만 거의 관찰되지 않는 세부 사항은 dag가 양의 똥으로 뒤덮인 털인 *daglock*을 가리키는 [애정 어린 호주 모욕](https://en.wikipedia.org/wiki/Dag_(slang))이라는 것입니다.

DAG는 변수 간의 인과 관계를 나타냅니다.
시각적으로 변수를 나타내는 방식은 **간선**과 **노드**입니다.
간선은 한 변수에서 다른 변수로 향하는 화살표이며, 때로는 호 또는 그냥 화살표라고도 합니다.
노드는 변수 자체이며, 때로는 정점, 점 또는 그냥 변수라고도 합니다.
@fig-dag-basic에는 두 개의 노드 `x`와 `y`가 있고 `x`에서 `y`로 향하는 하나의 간선이 있습니다.
여기서 우리는 `x`가 `y`를 유발한다고 말하고 있습니다.
`y`는 `x`를 "듣습니다" [@Pearl_Glymour_Jewell_2021].

```{r}
#| code-fold: true
#| message: false
#| label: fig-dag-basic
#| fig-width: 3
#| fig-height: 2
#| fig-cap: "인과적 방향성 비순환 그래프(DAG). DAG는 인과 관계를 나타냅니다. 이 DAG에서 가정은 `x`가 `y`를 유발한다는 것입니다."
library(ggdag)
dagify(y ~ x, coords = time_ordered_coords()) |>
  ggdag() +
  theme_dag() +
  expand_plot(expand_x = expansion(c(.2, .2)))
```

`x`가 `y`에 미치는 인과 효과에 관심이 있다면 해당 화살표의 숫자 표현을 추정하려고 합니다.
그러나 일반적으로 특정 질문의 인과 구조에는 다른 많은 변수와 화살표가 있습니다.
일련의 화살표를 **경로**라고 합니다.
DAG에서 볼 수 있는 세 가지 유형의 경로가 있습니다. **포크**, **체인**, **충돌자**(때로는 **역 포크**라고도 함).

```{r}
#| code-fold: true
#| label: fig-dag-path-types
#| fig-cap: "세 가지 유형의 인과 관계: 포크, 체인, 충돌자. 화살표의 방향과 관심 있는 관계는 일련의 변수가 어떤 유형의 경로인지 결정합니다. 포크는 공통 원인을 나타내고, 체인은 직접적인 원인을 나타내며, 충돌자는 공통 후손을 나타냅니다."
coords <- list(x = c(x = 0, y = 2, q = 1), y = c(x = 0, y = 0, q = 1))

fork <- dagify(
  x ~ q,
  y ~ q,
  exposure = "x",
  outcome = "y",
  coords = coords
)

chain <- dagify(
  q ~ x,
  y ~ q,
  exposure = "x",
  outcome = "y",
  coords = coords
)

collider <- dagify(
  q ~ x + y,
  exposure = "x",
  outcome = "y",
  coords = coords
)

dag_flows <- map(list(fork = fork, chain = chain, collider = collider), tidy_dagitty) |>
  map("data") |>
  list_rbind(names_to = "dag") |>
  mutate(dag = factor(dag, levels = c("fork", "chain", "collider")))

dag_flows |>
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(edge_width = 1) +
  geom_dag_point() +
  geom_dag_text() +
  facet_wrap(~dag) +
  expand_plot(
    expand_x = expansion(c(0.2, 0.2)),
    expand_y = expansion(c(0.2, 0.2))
  ) +
  theme_dag()
```

포크는 두 변수의 공통 원인을 나타냅니다.
여기서는 `q`가 `x`와 `y` 모두를 유발한다고 말하고 있으며, 이는 **교란 변수**의 전통적인 정의입니다.
`x`에서 `y`로 향하는 화살표가 서로 다른 방향이기 때문에 포크라고 불립니다.
반면에 체인은 같은 방향으로 향하는 일련의 화살표를 나타냅니다.
여기서 `q`는 **매개 변수**라고 불립니다. 즉, `x`에서 `y`로 이어지는 인과 경로에 있습니다.
이 다이어그램에서 `x`에서 `y`로 이어지는 유일한 경로는 `q`를 통해 매개됩니다.
마지막으로 충돌자는 두 개의 화살촉이 한 변수에서 만나는 경로입니다.
인과 관계는 항상 시간 순서대로 진행되므로 이는 자연스럽게 충돌자 변수가 다른 두 변수에 의해 유발됨을 의미합니다.
여기서는 `x`와 `y`가 모두 `q`를 유발한다고 말하고 있습니다.
종종 `q` 자체도 **충돌자**라고 불립니다.

::: callout-tip
## DAG는 SEM인가요?

심리학 및 기타 사회 과학 환경에서 일반적으로 사용되는 모델링 기법인 **구조 방정식 모델(SEM)**에 익숙하다면 SEM과 DAG 간에 몇 가지 유사점을 발견할 수 있습니다.
DAG는 *비모수적* SEM의 한 형태입니다.
SEM은 모수적 가정을 사용하여 전체 그래프를 추정합니다.
반면에 인과적 DAG는 아무것도 추정하지 않습니다. 한 변수에서 다른 변수로 향하는 화살표는 해당 관계의 강도나 함수 형태에 대해 아무것도 말하지 않으며, 단지 우리가 그것이 존재한다고 생각한다는 것만 말합니다.
:::

DAG의 중요한 이점 중 하나는 편향의 원인을 식별하는 데 도움이 되고 종종 이를 해결하는 방법에 대한 단서를 제공한다는 것입니다.
그러나 편향되지 않은 효과 추정치에 대해 이야기하는 것은 특정 인과적 질문을 염두에 둘 때만 의미가 있습니다.
각 화살표는 원인을 나타내므로 결국 모든 것은 인과 관계입니다. 본질적으로 문제가 있는 개별 화살표는 없습니다.
여기서는 `x`가 `y`에 미치는 영향에 관심이 있습니다.
이 질문은 우리가 관심 있는 경로와 그렇지 않은 경로를 정의합니다.

이 세 가지 유형의 경로는 `x`와 `y` 간의 통계적 관계에 대해 서로 다른 의미를 갖습니다.
이러한 가정 하에서 두 변수 간의 상관 관계만 살펴보면 다음과 같습니다.

1.  포크에서는 `x`에서 `y`로 향하는 화살표가 없음에도 불구하고 `x`와 `y`가 연관됩니다.
2.  체인에서는 `x`와 `y`가 `q`를 통해서만 관련됩니다.
3.  충돌자에서는 `x`와 `y`가 관련되지 *않습니다*.

연관성을 전달하는 경로를 **열린 경로**라고 합니다.
연관성을 전달하지 않는 경로를 **닫힌 경로**라고 합니다.
포크와 체인은 열려 있고 충돌자는 닫혀 있습니다.

그렇다면 `q`를 조정해야 할까요?
그것은 경로의 성격에 따라 다릅니다.
포크는 교란 경로입니다.
`q`가 `x`와 `y` 모두를 유발하기 때문에 `x`와 `y`는 가짜 연관성을 갖게 됩니다.
둘 다 공통 원인인 `q`의 정보를 포함합니다.
이러한 공통 인과 관계는 `x`와 `y`를 통계적으로 연관시킵니다.
`q`를 조정하면 교란으로 인한 편향을 **차단**하고 `x`와 `y` 간의 실제 관계를 얻을 수 있습니다.

::: callout-tip
## 조정

변수를 설명하기 위해 다양한 기법을 사용할 수 있습니다.
우리는 관심 없는 변수의 효과를 제거하는 모든 기법을 "조정" 또는 "통제"라고 부릅니다.
:::

@fig-confounder-scatter는 이 효과를 시각적으로 보여줍니다.
여기서 `x`와 `y`는 연속적이며 DAG의 정의에 따라 관련이 없습니다.
그러나 `q`는 둘 다 유발합니다.
조정되지 않은 효과는 `q`를 통해 `x`에서 `y`로 이어지는 열린 경로에 대한 정보를 포함하기 때문에 편향됩니다.
그러나 `q` 수준 내에서는 `x`와 `y`가 관련이 없습니다.

```{r}
#| code-fold: true
#| label: fig-confounder-scatter
#| message: false
#| fig-cap: "`x`와 `y` 간의 관계에 대한 두 개의 산점도. 포크를 사용하면 관계가 `q`에 의해 편향됩니다. `q`를 고려하면 실제 귀무 관계를 볼 수 있습니다."
set.seed(123)
library(patchwork)
n <- 1000

### q
q <- rbinom(n, size = 1, prob = .35)
###

### x
x <- 2 * q + rnorm(n)
###

### y
y <- -3 * q + rnorm(n)
###

confounder_data <- tibble(x, y, q = as.factor(q))

p1 <- confounder_data |>
  ggplot(aes(x, y)) +
  geom_point(alpha = .2) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  facet_wrap(~"`q`를 조정하지 않음\n(편향됨)")

p2 <- confounder_data |>
  ggplot(aes(x, y, color = q)) +
  geom_point(alpha = .2) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~"`q`를 조정함\n(편향되지 않음)")

p1 + p2
```

체인의 경우 매개 변수를 조정할지 여부는 연구 질문에 따라 다릅니다.
여기서 `q`를 조정하면 `x`가 `y`에 미치는 영향에 대한 귀무 추정치가 생성됩니다.
`x`가 `y`에 미치는 유일한 영향은 `q`를 통하기 때문에 다른 영향은 남아 있지 않습니다.
`q`를 통해 매개되는 `x`가 `y`에 미치는 영향을 **간접 효과**라고 하고, `x`가 `y`에 직접 미치는 영향을 **직접 효과**라고 합니다.
직접 효과에만 관심이 있다면 `q`를 통제하는 것이 우리가 원하는 것일 수 있습니다.
두 가지 효과 모두에 대해 알고 싶다면 `q`를 조정하려고 해서는 안 됩니다.
@sec-mediation에서 이러한 효과 및 기타 매개 효과를 추정하는 방법에 대해 자세히 알아볼 것입니다.

@fig-mediator-scatter는 이 효과를 시각적으로 보여줍니다.
`x`가 `y`에 미치는 조정되지 않은 효과는 전체 효과를 나타냅니다.
전체 효과는 전적으로 `q`를 통해 매개되는 경로 때문이므로 `q`를 조정하면 관계가 남아 있지 않습니다.
이 귀무 효과는 직접 효과입니다.
이러한 효과 중 어느 것도 편향 때문이 아니지만 각각 다른 연구 질문에 답합니다.

```{r}
#| code-fold: true
#| label: fig-mediator-scatter
#| message: false
#| fig-cap: "`x`와 `y` 간의 관계에 대한 두 개의 산점도. 체인을 사용하면 `q`를 고려해야 하는지 여부와 방법은 연구 질문에 따라 다릅니다. 그렇게 하지 않으면 `q`를 통한 간접 효과를 포함하여 `x`와 `y`의 전체 효과의 영향을 볼 수 있습니다. `q`를 고려하면 `x`가 `y`에 미치는 직접 (귀무) 효과를 볼 수 있습니다."
### x
x <- rnorm(n)
###

### q
linear_pred <- 2 * x + rnorm(n)
prob <- 1 / (1 + exp(-linear_pred))
q <- rbinom(n, size = 1, prob = prob)
###

### y
y <- 2 * q + rnorm(n)
###

mediator_data <- tibble(x, y, q = as.factor(q))

p1 <- mediator_data |>
  ggplot(aes(x, y)) +
  geom_point(alpha = .2) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  facet_wrap(~"`q`를 조정하지 않음\n(전체 효과)")

p2 <- mediator_data |>
  ggplot(aes(x, y, color = q)) +
  geom_point(alpha = .2) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~"`q`를 조정함\n(직접 효과)")

p1 + p2
```

충돌자는 다릅니다.
@fig-dag-path-types의 충돌자 DAG에서 `x`와 `y`는 연관되지 *않지만* 둘 다 `q`를 유발합니다.
`q`를 조정하면 교란과 반대 효과가 발생합니다. 즉, 편향 경로를 *엽니다*.
때로는 충돌자에 의해 열린 경로를 `x`와 `y`를 연결하는 것으로 그립니다.

시각적으로 `x`와 `y`가 연속적이고 `q`가 이진일 때 이를 볼 수 있습니다.
@fig-collider-scatter에서 `q`를 포함하지 않으면 `x`와 `y` 간에 관계가 없음을 알 수 있습니다.
그것이 올바른 결과입니다.
그러나 `q`를 포함하면 `x`와 `y` 모두에 대한 정보를 감지할 수 있으며 상관 관계가 있는 것처럼 보입니다. 즉, `x` 수준에 걸쳐 `q = 0`인 사람들은 `y` 수준이 낮습니다.
연관성은 겉보기에 시간을 거슬러 올라가는 것처럼 보입니다.
물론 인과적 관점에서는 그럴 수 없으므로 `q`를 통제하는 것은 잘못된 일입니다.
결국 `x`가 `y`에 미치는 편향된 효과를 얻게 됩니다.

```{r}
#| code-fold: true
#| label: fig-collider-scatter
#| message: false
#| fig-cap: "`x`와 `y` 간의 관계에 대한 두 개의 산점도. 둘 사이의 조정되지 않은 관계는 편향되지 않았습니다. `q`를 고려하면 충돌하는 백도어 경로를 열고 `x`와 `y` 간의 관계를 편향시킵니다."
#|
### x
x <- rnorm(n)
###

### y
y <- rnorm(n)
###

### q
linear_pred <- 2 * x + 3 * y + rnorm(n)
prob <- 1 / (1 + exp(-linear_pred))
q <- rbinom(n, size = 1, prob = prob)
###

collider_data <- tibble(x, y, q = as.factor(q))

p1 <- collider_data |>
  ggplot(aes(x, y)) +
  geom_point(alpha = .2) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  facet_wrap(~"`q`를 조정하지 않음\n(편향되지 않음)")

p2 <- collider_data |>
  ggplot(aes(x, y, color = q)) +
  geom_point(alpha = .2) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~"`q`를 조정함\n(편향됨)")

p1 + p2
```

어떻게 이럴 수 있을까요?
`x`와 `y`는 `q` 이전에 발생하므로 `q`는 영향을 미칠 수 없습니다.
DAG를 옆으로 돌려서 @fig-collider-time을 고려해 보겠습니다.
두 시점을 나누면 시점 1에서는 `q`가 아직 발생하지 않았고 `x`와 `y`는 관련이 없습니다.
시점 2에서는 `x`와 `y`로 인해 `q`가 발생합니다.
*그러나 인과 관계는 시간 순서대로만 진행됩니다*.
나중에 `q`가 발생한다고 해서 과거에 `x`와 `y`가 독립적으로 발생했다는 사실이 바뀌지는 않습니다.

```{r}
#| code-fold: true
#| label: fig-collider-time
#| fig-cap: "두 시점에 걸친 충돌자 관계. 시점 1에서는 `x`와 `y` 간에 관계가 없습니다. 둘 다 시점 2까지 `q`를 유발하지만, 이것이 시점 1에서 이미 일어난 일을 바꾸지는 않습니다."

coords <- list(x = c(x = 0, y = 2, q = 1), y = c(x = 0, y = 0, q = -1))
collider <- dagify(
  q ~ x + y,
  exposure = "x",
  outcome = "y",
  coords = time_ordered_coords()
)

collider_t <- collider |>
  tidy_dagitty() |>
  mutate(time = "시점 1", direction = NA, to = NA) |>
  filter(name != "q")

t2 <- collider |>
  tidy_dagitty() |>
  mutate(time = "시점 2") |>
  pull_dag_data()

collider_t$data <- bind_rows(collider_t$data, t2)

collider_t |>
  mutate(deemphasize = (name %in% c("x", "y") & time ==
    "시점 2")) |>
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(edge_width = 1, edge_color = "grey85") +
  geom_dag_point(aes(color = deemphasize), show.legend = FALSE) +
  geom_dag_text() +
  facet_wrap(~time) +
  theme_dag() +
  scale_color_manual(values = c("TRUE" = "grey85", "FALSE" = "black"))
```

인과 관계는 앞으로만 진행됩니다.
그러나 연관성은 시간에 구애받지 않습니다.
그것은 단지 변수 간의 수치적 관계에 대한 관찰일 뿐입니다.
미래를 통제할 때 편향을 도입할 위험이 있습니다.
이에 대한 직관을 개발하는 데 시간이 걸립니다.
`x`와 `y`가 `q`의 유일한 원인이고 세 변수 모두 이진인 경우를 생각해 보십시오.
`x` 또는 `y` 중 하나가 1이면 `q`가 발생합니다.
`q = 1`이고 `x = 0`임을 알면 논리적으로 `y = 1`이어야 합니다.
따라서 `q`에 대해 알면 `x`를 통해 `y`에 대한 정보를 얻을 수 있습니다.
이 예는 극단적이지만, 때때로 **충돌자 계층화 편향** 또는 **선택 편향**이라고 불리는 이러한 유형의 편향이 어떻게 발생하는지 보여줍니다. 즉, `q`에 대한 조건화는 `x`와 `y`에 대한 통계적 정보를 제공하고 관계를 왜곡합니다[@Banack2023].

::: callout-tip
## 교환 가능성 재검토

우리는 일반적으로 교환 가능성을 교란 없음의 가정이라고 부릅니다.
실제로 이것은 완전히 옳지 않습니다.
잠재적 결과의 교환 가능성을 위해서는 *열린, 비인과적* 경로가 없어야 합니다[@hernan2021].
많은 경우 이러한 경로는 교란 경로입니다.
그러나 충돌자에 대한 조건화도 경로를 열 수 있습니다.
이것이 교란 변수는 아니지만 그렇게 하면 두 그룹 간에 비 교환 가능성이 생성됩니다. 즉, 노출과 결과에 중요한 방식으로 다릅니다.

열린, 비인과적 경로는 **백도어 경로**라고도 합니다.
이 용어는 아이디어를 잘 포착하기 때문에 자주 사용할 것입니다. 즉, 이러한 경로는 우리가 추정하려는 효과를 편향시키는 모든 열린 경로입니다.
:::

따라서 노출과 결과 간의 인과 구조를 올바르게 식별하면 1) 변수 간의 관계에 대해 우리가 만드는 가정을 전달하고 2) 편향의 원인을 식별하는 데 도움이 됩니다.
중요한 것은 2)를 수행함으로써 1)의 가정을 기반으로 편향을 방지하는 방법을 종종 식별할 수 있다는 것입니다.
@fig-dag-path-types의 세 가지 DAG의 간단한 경우에서 인과 구조의 성격에 따라 `q`를 통제할지 여부를 알 수 있습니다.
조정해야 하는 변수 집합 또는 집합을 **조정 집합**이라고 합니다.
DAG는 복잡한 환경에서도 조정 집합을 식별하는 데 도움이 될 수 있습니다[@vanderzander2019].

::: callout-tip
## 상호 작용은 어떻습니까?

DAG는 추론의 중요한 부분임에도 불구하고 상호 작용이나 효과 추정치 수정에 대해 언급하지 않습니다.
기술적으로 상호 작용은 DAG의 관계의 함수 형태 문제입니다.
DAG에서 변수를 모델링하는 방법(예: 스플라인 사용)을 지정할 필요가 없는 것처럼 변수가 통계적으로 상호 작용하는 방법을 결정할 필요도 없습니다.
그것은 모델링 단계의 문제입니다.

인과 추론에서 상호 작용을 사용하는 여러 가지 방법이 있습니다.
극단적인 경우, 이는 단순히 함수 형태의 문제입니다. 즉, 상호 작용 항은 모델에 포함되지만 전체 인과 효과를 얻기 위해 주변화됩니다.
반대로 우리는 상호 작용하는 두 변수가 모두 인과적인 **공동 인과 효과**에 관심이 있습니다.
그 사이에서 상호 작용 항을 사용하여 인과적이라고 가정되지 않는 두 번째 변수에 따라 달라지는 **이질적인 인과 효과**를 식별할 수 있습니다.
인과 추론의 많은 도구와 마찬가지로 다른 질문에 답하기 위해 여러 가지 방법으로 동일한 통계 기법을 사용합니다.
[Chapter -@sec-interaction]에서 이 주제를 자세히 다시 다룰 것입니다.

많은 사람들이 다양한 유형의 호, 노드 및 기타 주석을 사용하여 DAG에서 상호 작용을 표현하려고 시도했지만 선호하는 방식으로 채택된 접근 방식은 없습니다[@weinberg2007; @Nilsson2021].
:::

R의 예를 살펴보겠습니다.
DAG를 만들고, 시각화하고, 조정 집합과 같은 중요한 정보를 식별하는 방법을 배울 것입니다.

## R의 DAG

먼저 연구 질문을 고려해 보겠습니다. 시험 전 아침에 코미디 팟캐스트를 듣는 것이 대학원생의 시험 점수를 향상시키는가?
@sec-diag(@fig-diagram-podcast)에 설명된 방법을 사용하여 이를 다이어그램으로 나타낼 수 있습니다.

```{r}
#| echo: false
#| fig-cap: "질문에 대한 문장 다이어그램: 시험 전 아침에 코미디 팟캐스트를 듣는 것이 대학원생 시험 점수를 향상시키는가? 모집단은 대학원생입니다. 시작 시간은 아침이고 결과 시간은 시험 후입니다."
#| fig-height: 2
#| label: fig-diagram-podcast
knitr::include_graphics("../images/podcast-diagram.png")
```

DAG를 만드는 데 사용할 도구는 ggdag입니다.
ggdag는 R에서 가장 강력한 시각화 도구인 ggplot2를 DAG 쿼리를 위한 정교한 알고리즘을 갖춘 R 패키지인 dagitty에 연결하는 패키지입니다.

DAG 객체를 만들려면 `dagify()` 함수를 사용합니다. `dagify()`는 dagitty 및 ggdag 패키지 모두에서 작동하는 `dagitty` 객체를 반환합니다.
`dagify()` 함수는 쉼표로 구분된 공식을 사용하며, 이 공식은 원인과 결과를 지정하며, 공식의 왼쪽 요소는 결과를 정의하고 오른쪽 요소는 이를 유발하는 모든 요인을 정의합니다.
이는 R의 대부분의 회귀 모델에 대해 지정하는 공식 유형과 같습니다.

```{r}
#| eval: false
dagify(
  결과1 ~ 원인1 + 원인2 + 원인3,
  결과2 ~ 원인1 + 원인4,
  ...
)
```

대학원생이 시험 전 아침에 팟캐스트를 듣게 만드는 모든 요인은 무엇일까요?
대학원생이 시험을 잘 보게 만드는 모든 요인은 무엇일까요?
여기에 몇 가지를 가정해 보겠습니다.

```{r}
library(ggdag)
dagify(
  podcast ~ mood + humor + prepared,
  exam ~ mood + prepared
)
```

위 코드에서 우리는 다음과 같이 가정합니다.

-   대학원생의 기분, 유머 감각, 시험 준비 정도가 시험 당일 아침에 팟캐스트를 들었는지 여부에 영향을 미칠 수 있습니다.
-   그들의 기분과 준비 정도도 시험 점수에 영향을 미칩니다.

시험 방정식에 팟캐스트가 *보이지 않는다는* 점에 유의하십시오. 이는 팟캐스트와 시험 점수 사이에 인과 관계가 *없다고* 가정한다는 의미입니다.

`dagify()`에 자주 제공하게 될 다른 유용한 인수가 몇 가지 있습니다.

-   `exposure` 및 `outcome`: 연구 질문의 노출 및 결과인 변수를 ggdag에 알려주는 것은 DAG에 대해 만들 수 있는 가장 유용한 쿼리 중 다수에 필요합니다.
-   `latent`: 이 인수를 사용하면 DAG의 일부 변수가 측정되지 않았음을 ggdag에 알릴 수 있습니다. `latent`는 실제로 가지고 있는 데이터로 유효한 조정 집합을 식별하는 데 도움이 됩니다.
-   `coords`: 변수의 좌표입니다. 아래에서 설명하는 것처럼 알고리즘 또는 수동 레이아웃 중에서 선택할 수 있습니다. 여기서는 `time_ordered_coords()`를 사용합니다.
-   `labels`: 변수에 대한 문자 벡터 레이블입니다.

이러한 속성 중 일부를 사용하여 DAG 객체 `podcast_dag`를 만든 다음 `ggdag()`로 DAG를 시각화해 보겠습니다.
`ggdag()`는 ggplot 객체를 반환하므로 테마와 같은 추가 레이어를 플롯에 추가할 수 있습니다.

```{r}
#| label: fig-dag-podcast
#| fig-cap: "질문에 답하기 위해 제안된 DAG: 시험 전 아침에 코미디 팟캐스트를 듣는 것이 대학원생 시험 점수를 향상시키는가?"
#| fig-width: 4
#| fig-height: 4
#| warning: false
podcast_dag <- dagify(
  podcast ~ mood + humor + prepared,
  exam ~ mood + prepared,
  coords = time_ordered_coords(
    list(
      # 시점 1
      c("prepared", "humor", "mood"),
      # 시점 2
      "podcast",
      # 시점 3
      "exam"
    )
  ),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    mood = "기분",
    humor = "유머",
    prepared = "준비됨"
  )
)
ggdag(podcast_dag, use_labels = "label", text = FALSE) +
  theme_dag()
```

::: callout-note
이 장의 나머지 부분에서는 DAG용으로 만들어진 ggplot 테마인 `theme_dag()`를 사용할 것입니다.

```{r}
theme_set(
  theme_dag() %+replace%
    # 또한 몇 가지 추가 스타일링 추가
    theme(
      legend.position = "bottom",
      strip.text.x = element_text(margin = margin(2, 0, 2, 0, "mm"))
    )
)
```
:::

::: callout-tip
## DAG 좌표

ggdag에 좌표를 지정할 필요는 없습니다.
지정하지 않으면 자동 레이아웃을 위해 설계된 알고리즘을 사용합니다.
이러한 알고리즘은 많이 있으며 모양, 노드 간 간격, 교차하는 간선 수 최소화 등 레이아웃의 다양한 측면에 중점을 둡니다.
이러한 레이아웃 알고리즘에는 일반적으로 무작위성 요소가 있으므로 동일한 결과를 얻으려면 시드를 사용하는 것이 좋습니다.

```{r}
#| fig-width: 4
#| fig-height: 4
#| fig-align: center
# 좌표 지정 안 함
set.seed(123)
pod_dag <- dagify(
  podcast ~ mood + humor + prepared,
  exam ~ mood + prepared
)

# 레이아웃 자동 결정
pod_dag |>
  ggdag(text_size = 2.8)
```

DAG에 널리 사용되는 Sugiyama 알고리즘과 같이 특정 레이아웃을 요청할 수도 있습니다[@sugiyama1981].

```{r}
#| fig-width: 4
#| fig-height: 4
#| fig-align: center
pod_dag |>
  ggdag(layout = "sugiyama", text_size = 2.8)
```

인과적 DAG의 경우 `time_ordered_coords()` 또는 `layout = "time_ordered"`로 지정할 수 있는 시간 순서 레이아웃 알고리즘이 가장 좋은 경우가 많습니다.
아래에서 시간 순서에 대해 자세히 논의할 것입니다.
앞서 어떤 변수가 어떤 시점에 있는지 ggdag에 명시적으로 알려주었지만 그럴 필요는 없습니다.
그러나 시간 순서 알고리즘은 하나가 다른 하나를 유발하지 않으므로(따라서 그보다 먼저 발생하지 않음) `podcast`와 `exam`을 동일한 시점에 배치한다는 점에 유의하십시오.
그렇지 않다는 것을 알고 있습니다. 팟캐스트를 듣는 것은 시험을 보기 전에 일어났습니다.

<!-- TODO: 하나 이상의 시점을 지정하면서 이 알고리즘을 사용하는 더 좋은 방법을 구현하는 경우 이를 업데이트합니다. -->

```{r}
#| fig-width: 4
#| fig-height: 4
#| fig-align: center
pod_dag |>
  ggdag(layout = "time_ordered", text_size = 2.8)
```

목록이나 데이터 프레임을 사용하여 좌표를 수동으로 지정하고 `dagify()`의 `coords` 인수에 제공할 수 있습니다.
또한 ggdag는 dagitty를 기반으로 하므로 [dagitty 웹 앱](https://dagitty.net/)을 사용하여 그래픽 인터페이스를 통해 DAG를 만들고 구성한 다음 결과를 dagitty 코드로 내보내어 ggdag에서 사용할 수 있습니다.

알고리즘 레이아웃은 DAG 또는 특히 복잡한 그래프를 빠르게 시각화하는 데 유용합니다.
DAG를 공유하려면 일반적으로 레이아웃에 대해 더 의도적으로, 아마도 좌표를 수동으로 지정하는 것이 가장 좋습니다.
`time_ordered_coords()`는 종종 두 가지 모두의 장점을 가지고 있으며 이 책의 대부분의 DAG에 사용할 것입니다.
:::

이 질문에 대한 DAG를 지정하고 관심 있는 노출과 결과가 무엇인지 ggdag에 알려주었습니다.
DAG에 따르면 팟캐스트 청취와 시험 점수 사이에는 직접적인 인과 관계가 없습니다.
다른 열린 경로가 있습니까?
`ggdag_paths()`는 DAG를 가져와 열린 경로를 시각화합니다.
@fig-paths-podcast에서는 두 개의 열린 경로를 볼 수 있습니다. 즉, `podcast <- mood -> exam`과 `podcast <- prepared -> exam`입니다. 이들은 모두 포크, 즉 *교란 경로*입니다. 팟캐스트 청취와 시험 점수 사이에 인과 관계가 없으므로 유일한 열린 경로는 *백도어* 경로, 즉 이 두 교란 경로입니다.

```{r}
#| label: fig-paths-podcast
#| fig-cap: "`ggdag_paths()`는 DAG의 열린 경로를 시각화합니다. `podcast_dag`에는 두 개의 열린 경로가 있습니다. 즉, `mood`의 포크와 `prepared`의 포크입니다."
podcast_dag |>
  # 경로뿐만 아니라 전체 dag를 밝은 회색 "그림자"로 표시합니다.
  # 경로만 표시하는 대신
  ggdag_paths(shadow = TRUE, text = FALSE, use_labels = "label")
```

::: callout-tip
`dagify()`는 `dagitty()` 객체를 반환하지만 내부적으로 ggdag는 `dagitty` 객체를 `dagitty` 객체와 DAG에 대한 `dataframe`을 모두 보유하는 구조인 깔끔한 DAG로 변환합니다.
이는 DAG를 프로그래밍 방식으로 조작하려는 경우에 유용합니다.

```{r}
podcast_dag_tidy <- podcast_dag |>
  tidy_dagitty()

podcast_dag_tidy
```

대부분의 빠른 플로팅 함수는 `dagitty` 객체가 아직 깔끔한 DAG가 아닌 경우 깔끔한 DAG로 변환한 다음 어떤 식으로든 데이터를 조작합니다.
예를 들어, `dag_paths()`는 `ggdag_paths()`의 기초가 됩니다. 경로에 대한 데이터가 있는 깔끔한 DAG를 반환합니다.
이러한 객체에 대해 여러 dplyr 함수를 직접 사용할 수 있습니다.

```{r}
podcast_dag_tidy |>
  dag_paths() |>
  filter(set == 2, path == "open path")
```

깔끔한 DAG는 순수한 데이터 프레임은 아니지만 `pull_dag_data()` 또는 `pull_dag()`를 사용하여 `dataframe` 또는 `dagitty` 객체를 검색하여 직접 작업할 수 있습니다.
`pull_dag()`는 dagitty 함수로 작업하려는 경우에 유용할 수 있습니다.

```{r}
library(dagitty)
podcast_dag_tidy |>
  pull_dag() |>
  paths()
```
:::

백도어 경로는 `podcast`와 `exam` 간의 통계적 연관성을 오염시키므로 이를 설명해야 합니다.
`ggdag_adjustment_set()`은 DAG에서 암시하는 유효한 조정 집합을 시각화합니다.
@fig-podcast-adustment-set은 조정된 변수를 정사각형으로 표시합니다.
조정된 변수에서 나오는 모든 화살표는 해당 변수에서 경로가 더 이상 열려 있지 않으므로 DAG에서 제거됩니다.

```{r}
#| label: fig-podcast-adustment-set
#| fig-width: 8
#| fig-height: 4
#| fig-align: center
#| fig-cap: "팟캐스트-시험 DAG에 대한 최소 조정 집합 시각화. 이 DAG가 정확하다면 백도어 경로를 차단하는 데 두 가지 변수가 필요합니다. 즉, `mood`와 `prepared`입니다."
ggdag_adjustment_set(
  podcast_dag,
  text = FALSE,
  use_labels = "label"
)
```

@fig-podcast-adustment-set은 **최소 조정 집합**을 보여줍니다.
기본적으로 ggdag는 가능한 한 가장 적은 수의 변수로 모든 백도어 경로를 닫을 수 있는 집합을 반환합니다.
이 DAG에서는 단 하나의 집합, 즉 `mood`와 `prepared`입니다.
이 집합은 두 개의 백도어 경로가 있고 노출과 결과 외에 다른 유일한 변수가 이 두 변수이기 때문에 의미가 있습니다.
따라서 유효한 추정치를 얻으려면 최소한 두 가지 모두를 설명해야 합니다.

::: callout-tip
`ggdag()` 및 유사 함수는 일반적으로 `tidy_dagitty()` 및 `dag_*()` 또는 `node_*()` 함수를 사용하여 기본 데이터 프레임을 변경합니다.
마찬가지로 빠른 플로팅 함수는 ggdag의 geom을 사용하여 결과 DAG를 시각화합니다.
즉, 매일 사용하는 것과 동일한 데이터 조작 및 시각화 전략을 ggdag에서 직접 사용할 수 있습니다.

다음은 `ggdag_adjustment_set()`이 수행하는 작업의 요약 버전입니다.

```{r}
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-align: center
podcast_dag_tidy |>
  # 데이터에 조정 집합 추가
  dag_adjustment_sets() |>
  ggplot(aes(
    x = x,
    y = y,
    xend = xend,
    yend = yend,
    color = adjusted,
    shape = adjusted
  )) +
  # ggdag의 사용자 정의 geom: 노드, 간선 및 레이블 추가
  geom_dag_point() +
  # 조정된 경로 제거
  geom_dag_edges_link(data = \(.df) filter(.df, adjusted != "adjusted")) +
  geom_dag_label_repel() +
  # 모든 ggplot 함수도 사용할 수 있습니다.
  facet_wrap(~set) +
  scale_shape_manual(values = c(adjusted = 15, unadjusted = 19))
```
:::

최소 조정 집합은 유효한 조정 집합의 한 가지 유형일 뿐입니다 [@vanderzander2019].
때로는 다른 변수 조합으로 편향되지 않은 효과 추정치를 얻을 수 있습니다.
ggdag에서 사용할 수 있는 다른 두 가지 옵션은 **전체 조정 집합**과 **표준 조정 집합**입니다.
전체 조정 집합은 유효한 집합을 생성하는 모든 변수 조합입니다.

```{r}
#| label: fig-adustment-set-all
#| fig-width: 6.5
#| fig-height: 5
#| fig-align: center
#| fig-cap: "`podcast_dag`에 대한 모든 유효한 조정 집합."
ggdag_adjustment_set(
  podcast_dag,
  text = FALSE,
  use_labels = "label",
  # 전체 조정 집합 가져오기
  type = "all"
)
```

`humor`도 통제할 수 있음이 밝혀졌습니다.

표준 조정 집합은 좀 더 복잡합니다. 즉, 노출 및 결과의 모든 가능한 조상에서 가능성 있는 후손을 뺀 것입니다.
완전히 포화된 DAG(모든 노드가 시간상 그 뒤에 오는 모든 것을 유발하는 DAG)에서 표준 조정 집합은 최소 조정 집합입니다.

::: callout-tip
ggdag의 대부분의 함수는 내부적으로 dagitty를 사용합니다.
dagitty 함수를 직접 호출하는 것이 종종 유용합니다.

```{r}
adjustmentSets(podcast_dag, type = "canonical")
```
:::

제안된 DAG를 사용하여 실제에서 최소 조정 집합을 설명하는 방법이 어떻게 발생하는지 확인하기 위해 일부 데이터를 시뮬레이션해 보겠습니다.

```{r}
set.seed(10)
sim_data <- podcast_dag |>
  simulate_data()

sim_data
```

@fig-dag-sim은 DAG를 기반으로 시뮬레이션된 데이터를 사용한 추정치의 포레스트 플롯을 보여줍니다.
한 추정치는 조정되지 않았고 다른 추정치는 `mood`와 `prepared`에 대해 조정되었습니다.
조정되지 않은 추정치는 가짜 효과를 초래했습니다(실제 값은 0인데 추정치는 -0.1).
반대로 `ggdag_adjustment_set()`에서 제안한 두 변수에 대해 조정한 추정치는 가짜가 아닙니다(0에 훨씬 가깝습니다).

```{r}
#| label: fig-dag-sim
#| fig-cap: "@fig-dag-podcast에 설명된 DAG를 기반으로 한 시뮬레이션 데이터의 포레스트 플롯."
#| code-fold: true
## 백도어 경로를 닫지 않는 모델
library(broom)
unadjusted_model <- lm(exam ~ podcast, sim_data) |>
  tidy(conf.int = TRUE) |>
  filter(term == "podcast") |>
  mutate(formula = "조정되지 않음")

## 백도어 경로를 닫는 모델
adjusted_model <- lm(exam ~ podcast + mood + prepared, sim_data) |>
  tidy(conf.int = TRUE) |>
  filter(term == "podcast") |>
  mutate(formula = "mood + prepared")

bind_rows(
  unadjusted_model,
  adjusted_model
) |>
  ggplot(aes(x = estimate, y = formula, xmin = conf.low, xmax = conf.high)) +
  geom_vline(xintercept = 0, linewidth = 1, color = "grey80") +
  geom_pointrange(fatten = 3, size = 1) +
  theme_minimal(18) +
  labs(
    y = NULL,
    caption = "올바른 효과 크기: 0"
  )
```

물론 우리는 실제 DAG로 작업하고 있다는 것을 알고 있습니다.
실제 DAG(@fig-dag-podcast)를 모르고 @fig-dag-podcast-wrong을 그렸다고 가정해 보겠습니다.

```{r}
#| label: fig-dag-podcast-wrong
#| fig-cap: "질문에 답하기 위해 제안된 DAG: 시험 전 아침에 코미디 팟캐스트를 듣는 것이 대학원생 시험 점수를 향상시키는가? 이번에는 잘못된 DAG를 제안했습니다."
#| fig-width: 4
#| fig-height: 4
#| warning: false
#| code-fold: true
podcast_dag_wrong <- dagify(
  podcast ~ humor + prepared,
  exam ~ prepared,
  coords = time_ordered_coords(
    list(
      # 시점 1
      c("prepared", "humor"),
      # 시점 2
      "podcast",
      # 시점 3
      "exam"
    )
  ),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    humor = "유머",
    prepared = "준비됨"
  )
)
ggdag(podcast_dag_wrong, use_labels = "label", text = FALSE) +
  theme_dag()
```

DAG가 잘못되었으므로 올바른 답을 얻는 데 도움이 되지 않습니다.
`prepared`만 조정하면 된다고 하지만 관계를 교란시키는 인과 경로를 놓치고 있습니다.
이제 어느 추정치도 옳지 않습니다.

```{r}
#| label: fig-dag-sim-wrong
#| fig-cap: "@fig-dag-podcast에 설명된 DAG를 기반으로 한 시뮬레이션 데이터의 포레스트 플롯. 그러나 @fig-dag-podcast-wrong의 조정 집합을 사용하여 분석하여 잘못된 답을 얻었습니다."
#| code-fold: true
## 백도어 경로를 닫지 않는 모델
library(broom)
unadjusted_model <- lm(exam ~ podcast, sim_data) |>
  tidy(conf.int = TRUE) |>
  filter(term == "podcast") |>
  mutate(formula = "조정되지 않음")

## 백도어 경로를 닫는 모델
adjusted_model <- lm(exam ~ podcast + prepared, sim_data) |>
  tidy(conf.int = TRUE) |>
  filter(term == "podcast") |>
  mutate(formula = "준비됨")

bind_rows(
  unadjusted_model,
  adjusted_model
) |>
  ggplot(aes(x = estimate, y = formula, xmin = conf.low, xmax = conf.high)) +
  geom_vline(xintercept = 0, linewidth = 1, color = "grey80") +
  geom_pointrange(fatten = 3, size = 1) +
  theme_minimal(18) +
  labs(
    y = NULL,
    caption = "올바른 효과 크기: 0"
  )
```

## 인과 관계의 구조

### 고급 교란

`podcast_dag`에서 `mood`와 `prepared`는 *직접적인* 교란 변수였습니다. 즉, `podcast`와 `exam`으로 직접 향하는 화살표가 있었습니다.
종종 백도어 경로는 더 복잡합니다.
두 개의 새로운 변수인 `alertness`와 `skills_course`를 추가하여 이러한 경우를 고려해 보겠습니다.
`alertness`는 좋은 기분에서 오는 각성감을 나타내므로 `mood`에서 `alertness`로 향하는 화살표가 있습니다.
`skills_course`는 학생이 대학 기술 과정을 수강하여 시간 관리 기법을 배웠는지 여부를 나타냅니다.
이제 `skills_course`는 팟캐스트를 들을 시간을 확보하고 시험 준비를 하는 데 필요한 것입니다.
`mood`와 `prepared`는 더 이상 직접적인 교란 변수가 아닙니다. 더 복잡한 백도어 경로를 따라 있는 두 변수입니다.
또한 `humor`에서 `mood`로 향하는 화살표를 추가했습니다.
@fig-podcast_dag2를 살펴보겠습니다.

```{r}
#| label: fig-podcast_dag2
#| fig-width: 5
#| fig-height: 4
#| fig-cap: "두 개의 추가 변수인 대학 기술 과정을 나타내는 `skills_course`와 각성감을 나타내는 `alertness`를 포함하는 `podcast_dag`의 확장 버전입니다."
podcast_dag2 <- dagify(
  podcast ~ mood + humor + skills_course,
  alertness ~ mood,
  mood ~ humor,
  prepared ~ skills_course,
  exam ~ alertness + prepared,
  coords = time_ordered_coords(),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    mood = "기분",
    alertness = "각성도",
    skills_course = "대학\n기술 과정",
    humor = "유머",
    prepared = "준비됨"
  )
)

ggdag(podcast_dag2, use_labels = "label", text = FALSE)
```

```{r}
#| echo: false
paths <- paths(podcast_dag2)
open_paths <- glue::glue_collapse(glue::glue("`{paths$paths[paths$open]}`"), sep = ", ", last = ", and")
adj_sets <- unclass(adjustmentSets(podcast_dag2)) |> map_chr(\(.x) glue::glue('{unlist(glue::glue_collapse(.x, sep = " + "))}'))
adj_sets <- glue::glue("`{adj_sets}`")
```

이제 닫아야 할 백도어 경로가 *세 개* 있습니다. `r open_paths`.

```{r}
#| label: fig-podcast_dag2-paths
#| fig-width: 11
#| fig-height: 4.5
#| fig-cap: "`podcast_dag2`의 세 개의 열린 경로. `podcast`가 `exam`에 미치는 영향이 없으므로 세 개 모두 올바른 효과를 얻기 위해 닫아야 하는 백도어 경로입니다."
ggdag_paths(podcast_dag2, use_labels = "label", text = FALSE, shadow = TRUE)
```

세 경로 모두를 닫는 최소 조정 집합은 4개입니다(그리고 전체 조정 집합은 18개!).
최소 조정 집합은 `r adj_sets`입니다.
이제 여러 가지 방법으로 열린 경로를 차단할 수 있습니다.
`mood`와 `prepared`는 여전히 작동하지만 이제 다른 옵션이 있습니다.
특히 `prepared`와 `alertness`는 동시에 또는 `podcast` 이후에도 발생할 수 있습니다.
`skills_course`와 `mood`는 여전히 `podcast`와 `exam` 모두 이전에 발생하므로 아이디어는 여전히 동일합니다. 즉, 교란 경로는 노출과 결과 이전에 시작됩니다.

```{r}
#| label: fig-podcast_dag2-set
#| fig-width: 7
#| fig-height: 8
#| fig-cap: "@fig-podcast_dag2-paths의 백도어 경로를 닫을 유효한 최소 조정 집합."
ggdag_adjustment_set(podcast_dag2, use_labels = "label", text = FALSE)
```

이러한 조정 집합 중에서 결정하는 것은 판단의 문제입니다. 모든 데이터가 완벽하게 측정되고 DAG가 정확하며 올바르게 모델링했다면 어떤 것을 사용하든 중요하지 않습니다.
각 조정 집합은 편향되지 않은 추정치를 생성합니다.
이 세 가지 가정은 모두 어느 정도 사실이 아닌 경우가 많습니다.
`skills_course`와 `prepared`를 통한 경로를 고려해 보겠습니다.
시험 준비 정도보다 대학 기술 과정을 수강했는지 여부를 더 잘 평가할 수 있을 수 있습니다.
이 경우 `skills_course`가 있는 조정 집합이 더 나은 옵션입니다.
그러나 준비도와 시험 결과 간의 관계를 더 잘 이해하고 있을 수도 있습니다.
측정했다면 그것을 통제하는 것이 더 나을 수 있습니다.
두 변수를 모두 포함하여 두 가지 모두의 장점을 얻을 수 있습니다. 즉, `skills_course`의 더 나은 측정과 `prepared`의 더 나은 모델링 사이에서 이 경로에서 교란을 최소화할 가능성이 더 높을 수 있습니다.

### 선택 편향 및 매개

선택 편향은 충돌자를 조정함으로써 유발되는 편향 유형의 또 다른 이름입니다[@lu2022].
충돌자로 인한 편향의 일반적인 형태는 연구 설계에 의해 본질적으로 계층화된 변수, 즉 연구 *참여* 선택이기 때문에 "선택 편향"이라고 불립니다.
원래 `podcast_dag`를 기반으로 하지만 학생이 시험에 출석했는지 여부라는 추가 변수가 있는 경우를 고려해 보겠습니다.
이제 `podcast`가 `exam`에 미치는 간접적인 영향이 있습니다. 즉, 팟캐스트를 듣는 것이 학생이 시험에 참석하는지 여부에 영향을 미칩니다.
출석하지 않은 사람들의 경우 `exam`의 실제 결과가 누락되었습니다. 출석한 사람들의 그룹을 연구함으로써 이 변수에 대해 본질적으로 계층화하고 있습니다.

```{r}
#| label: fig-podcast_dag3
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-cap: "`podcast_dag`의 또 다른 변형으로, 이번에는 시험에 출석한 사람들에 대한 본질적인 계층화를 포함합니다. `podcast`가 `exam`에 미치는 직접적인 영향은 여전히 없지만 `showed_up`을 통한 간접적인 영향이 있습니다."
podcast_dag3 <- dagify(
  podcast ~ mood + humor + prepared,
  exam ~ mood + prepared + showed_up,
  showed_up ~ podcast + mood + prepared,
  coords = time_ordered_coords(
    list(
      # 시점 1
      c("prepared", "humor", "mood"),
      # 시점 2
      "podcast",
      "showed_up",
      # 시점 3
      "exam"
    )
  ),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    mood = "기분",
    humor = "유머",
    prepared = "준비됨",
    showed_up = "출석함"
  )
)
ggdag(podcast_dag3, use_labels = "label", text = FALSE)
```

문제는 `showed_up`이 충돌자이자 매개 변수라는 것입니다. 즉, 계층화하면 DAG의 많은 변수 간에 관계가 유도되지만 `podcast`가 `exam`에 미치는 간접적인 영향은 차단됩니다.
다행히 조정 집합은 첫 번째 문제를 처리할 수 있습니다. `showed_up`이 `exam` *이전에* 발생하기 때문에 노출과 결과 간의 충돌자 편향 위험이 적습니다.
불행히도 효과의 일부가 누락되었기 때문에 `podcast`가 `exam`에 미치는 전체 효과를 계산할 수 없습니다. 즉, 간접적인 영향이 `showed_up`에서 닫힙니다.

```{r}
#| label: fig-podcast_dag3-as
#| fig-width: 4.5
#| fig-height: 4
#| warning: false
#| fig-cap: "데이터가 시험 출석 여부에 따라 본질적으로 조건화된다는 점을 고려한 `podcast_dag3`의 조정 집합. 이 경우 `podcast`가 `exam`에 미치는 전체 효과의 편향되지 않은 추정치를 복구할 방법이 없습니다."
podcast_dag3 |>
  adjust_for("showed_up") |>
  ggdag_adjustment_set(text = FALSE, use_labels = "label")
```

때로는 추정하려는 추정량을 변경하여 이 상황에서 여전히 효과를 추정할 수 있습니다.
간접적인 효과가 누락되었기 때문에 전체 효과를 계산할 수는 없지만 `podcast`가 `exam`에 미치는 직접적인 효과는 여전히 계산할 수 있습니다.

```{r}
#| label: fig-podcast_dag3-direct
#| fig-width: 4.5
#| fig-height: 4
#| warning: false
#| fig-cap: "다른 효과를 대상으로 할 때 `podcast_dag3`의 조정 집합. `podcast`가 `exam`에 미치는 직접적인 효과를 추정하는 데 사용할 수 있는 최소 조정 집합이 하나 있습니다."
podcast_dag3 |>
  adjust_for("showed_up") |>
  ggdag_adjustment_set(effect = "direct", text = FALSE, use_labels = "label")
```

#### M-편향 및 나비 편향 {#sec-m-bias}

종종 사람들이 이야기하는 특정 선택 편향 사례는 **M-편향**입니다.
위에서 아래로 배열했을 때 M자 모양이기 때문에 M-편향이라고 불립니다.

```{r}
#| label: fig-m-bias
#| fig-width: 4
#| fig-height: 4
#| fig-cap: "M-편향을 나타내는 DAG. 충돌자가 노출 및 결과보다 먼저 발생하는 상황입니다."
m_bias() |>
  ggdag()
```

::: callout-tip
ggdag에는 `confounder_triangle()`, `collider_triangle()`, `m_bias()` 및 `butterfly_bias()`를 포함하여 기본 인과 구조를 보여주는 여러 빠른 DAG가 있습니다.
:::

M-편향에 대해 이론적으로 흥미로운 점은 `m`이 충돌자이지만 `x`와 `y` 이전에 발생한다는 것입니다.
충돌자에서 연관성이 차단되므로 `x`와 `y` 사이에 열린 경로가 없다는 것을 기억하십시오.

```{r}
paths(m_bias())
```

팟캐스트-시험 DAG의 `mood` 경로에 초점을 맞춰 보겠습니다.
기분에 대해 우리가 틀렸고 실제 관계가 M자 모양이었다면 어떨까요?
`mood`가 `podcast`와 `exam`을 유발하는 대신 @fig-podcast_dag4에서와 같이 `podcast`와 `exam`의 공통 원인인 `u1`과 `u2`에 의해 유발되었다고 가정해 보겠습니다.
`u1`과 `u2`가 무엇인지 모르고 측정하지도 않았습니다.
위와 같이 이 DAG 하위 집합에는 열린 경로가 없습니다.

```{r}
#| label: fig-podcast_dag4
#| fig-width: 5.5
#| fig-height: 4
#| fig-cap: "`mood`가 M자 모양 경로의 충돌자인 @fig-dag-podcast의 재구성."
podcast_dag4 <- dagify(
  podcast ~ u1,
  exam ~ u2,
  mood ~ u1 + u2,
  coords = time_ordered_coords(list(
    c("u1", "u2"),
    "mood",
    "podcast",
    "exam"
  )),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    mood = "기분",
    u1 = "측정되지 않음",
    u2 = "측정되지 않음"
  ),
  # 측정하지 않았습니다.
  latent = c("u1", "u2")
)

ggdag(podcast_dag4, use_labels = "label", text = FALSE)
```

원래 DAG가 올바른 DAG라고 생각할 때 문제가 발생합니다. 즉, `mood`가 조정 집합에 있으므로 통제합니다.
그러나 이것은 편향을 유발합니다!
`u1`과 `u2` 사이에 경로를 열어 `podcast`에서 `exam`으로 이어지는 경로를 만듭니다.
`u1` 또는 `u2` 중 하나를 측정했다면 이 경로를 닫기 위해 조정할 수 있지만 그렇지 않습니다.
이 열린 경로를 닫을 방법이 없습니다.

```{r}
#| label: fig-podcast_dag4-as
#| warning: false
#| fig-width: 5.5
#| fig-height: 4.5
#| fig-cap: "`mood`가 충돌자인 조정 집합. `mood`를 통제하고 `mood`의 측정되지 않은 원인에 대해 모르거나 가지고 있지 않으면 충돌자를 조정하여 열린 백도어 경로를 닫을 방법이 없습니다."
podcast_dag4 |>
  adjust_for("mood") |>
  ggdag_adjustment_set(use_labels = "label", text = FALSE)
```

물론 여기서 가장 좋은 방법은 `mood`를 전혀 통제하지 않는 것입니다.
그러나 때로는 그것이 선택 사항이 아닐 수도 있습니다.
`mood` 대신 이것이 `showed_up`의 실제 구조로 밝혀졌다고 상상해 보십시오. `showed_up`을 본질적으로 통제하고 측정되지 않은 변수가 없으므로 연구 결과는 항상 편향될 것입니다.
그것이 편향의 정도를 이해하기 위해 민감도 분석으로 해결할 수 있도록 우리가 그 상황에 있는지 이해하는 것이 중요합니다.

`mood`가 `podcast`와 `exam`을 유발하고 `u1`과 `u2`가 `mood`와 노출 및 결과의 공통 원인인 M-편향의 변형을 고려해 보겠습니다.
이 배열은 모양 때문에 때때로 나비 또는 나비넥타이 편향이라고 불립니다.

```{r}
#| label: fig-butterfly_bias
#| fig-width: 5
#| fig-height: 4
#| fig-cap: "나비 편향에서 `mood`는 충돌자이자 교란 변수입니다. `mood`로 인한 편향을 통제하면 충돌자에 대해서도 조건화했기 때문에 새로운 경로가 열립니다. `u1` 또는 `u2` 없이는 모든 백도어 경로를 제대로 닫을 수 없습니다."
butterfly_bias(x = "podcast", y = "exam", m = "mood", a = "u1", b = "u2") |>
  ggdag(text = FALSE, use_labels = "label")
```

이제 어려운 상황에 처했습니다. 즉, `mood`가 교란 변수이기 때문에 통제해야 하지만, `mood`를 통제하면 `u1`에서 `u2`로 이어지는 경로가 열립니다.
어느 변수도 측정하지 않았기 때문에 `mood`에 대한 조건화에서 열린 경로를 닫을 수 없습니다.
어떻게 해야 할까요?
의심스러울 때는 `mood`를 통제하는 것이 두 가지 옵션 중 더 나은 것으로 밝혀졌습니다. 즉, 교란 편향이 충돌자 편향보다 더 나쁜 경향이 있으며, M자 모양의 충돌자 구조는 약간의 편차에 민감합니다(예: 이것이 정확한 구조가 아닌 경우 종종 편향이 그다지 나쁘지 않음) [@DingMiratrix2015].

선택 편향의 또 다른 일반적인 형태는 **추적 손실**입니다. 즉, 사람들이 노출 및 결과와 관련된 방식으로 연구에서 중도 탈락합니다.
[Chapter -@sec-longitudinal]에서 이 주제로 다시 돌아올 것입니다.

### 노출의 원인, 결과의 원인

중요한 또 다른 유형의 인과 구조를 고려해 보겠습니다. 즉, 노출의 원인이지만 결과의 원인은 아닌 것과 그 반대, 즉 결과의 원인이지만 노출의 원인은 아닌 것입니다.
원래 DAG에 `grader_mood`라는 변수를 추가해 보겠습니다.

```{r}
#| label: fig-podcast_dag5
#| fig-width: 5
#| fig-height: 4
#| fig-cap: "결과의 원인이 아닌 노출의 원인(`humor`)과 노출의 원인이 아닌 결과의 원인(`grader_mood`)을 포함하는 DAG."
podcast_dag5 <- dagify(
  podcast ~ mood + humor + prepared,
  exam ~ mood + prepared + grader_mood,
  coords = time_ordered_coords(
    list(
      # 시점 1
      c("prepared", "humor", "mood"),
      # 시점 2
      c("podcast", "grader_mood"),
      # 시점 3
      "exam"
    )
  ),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    mood = "학생\n기분",
    humor = "유머",
    prepared = "준비됨",
    grader_mood = "채점자\n기분"
  )
)
ggdag(podcast_dag5, use_labels = "label", text = FALSE)
```

이제 노출과 결과 *모두*와 관련되지 않은 두 가지 변수가 있습니다. 즉, `podcast`를 유발하지만 `exam`은 유발하지 않는 `humor`와 `exam`을 유발하지만 `podcast`는 유발하지 않는 `grader_mood`입니다.
`humor`부터 시작하겠습니다.

노출은 유발하지만 결과는 유발하지 않는 변수를 **도구 변수(IV)**라고도 합니다.
IV는 특정 조건 하에서 이를 통제하면 다른 유형의 편향을 악화시킬 수 있는 특이한 상황입니다.
이에 대해 독특한 점은 IV가 노출이 결과에 미치는 편향되지 않은 효과를 추정하는 완전히 다른 접근 방식을 수행하는 데 *또한* 사용될 수 있다는 것입니다.
IV는 계량 경제학에서 이 방식으로 일반적으로 사용되며 다른 분야에서도 점점 더 인기를 얻고 있습니다.
요컨대, IV 분석을 통해 지금까지 이야기한 접근 방식과 다른 가정 집합을 사용하여 인과 효과를 추정할 수 있습니다.
때로는 성향 점수 방법을 사용하여 다루기 어려운 문제를 IV를 사용하여 해결할 수 있으며 그 반대의 경우도 마찬가지입니다.
@sec-iv-friends에서 IV에 대해 자세히 이야기할 것입니다.

그렇다면 IV 방법을 사용하지 *않는* 경우 교란을 해결하기 위한 모델에 IV를 포함해야 할까요?
변수가 IV인지 아닌지 확실하지 않은 경우 모델에 추가해야 합니다. 즉, IV보다 교란 변수일 가능성이 더 높으며, 실제로 IV를 추가하는 것에서 오는 편향은 일반적으로 작습니다.
따라서 잠재적인 M-구조 변수를 조정하는 것과 마찬가지로 교란으로 인한 편향 위험이 더 나쁩니다[@Myers2011].

이제 IV의 반대, 즉 결과의 원인이지만 노출의 원인은 아닌 것에 대해 이야기해 보겠습니다.
이러한 변수는 때때로 **경쟁 노출**(결과도 유발하기 때문에) 또는 **정밀 변수**(보게 되겠지만 인과 추정치의 정밀도를 높이기 때문에)라고 불립니다.
당면한 연구 질문과의 관계에 관심이 있고 그들이 노출인 다른 연구 질문에는 관심이 없기 때문에 정밀 변수라고 부를 것입니다[@Brookhart2006].

IV와 마찬가지로 정밀 변수는 노출에서 결과로 이어지는 경로를 따라 발생하지 않습니다.
따라서 이를 포함할 필요는 없습니다.
IV와 달리 정밀 변수를 포함하는 것은 유익합니다.
결과의 다른 원인을 포함하면 통계 모델이 변동의 일부를 포착하는 데 도움이 됩니다.
이는 효과의 점 추정치에는 영향을 미치지 않지만 분산을 줄여 표준 오차를 작게 하고 신뢰 구간을 좁힙니다.
따라서 가능하면 포함하는 것이 좋습니다.

따라서 `grader_mood`를 통제할 필요는 없지만 데이터셋에 있다면 그렇게 해야 합니다.
마찬가지로 `humor`는 실제로 교란 변수일 수 있다고 생각하지 않는 한 모델에 좋은 추가 사항이 아닙니다. 유효한 도구라면 대신 효과를 추정하기 위해 IV 방법을 사용하는 것을 고려할 수 있습니다.

### 측정 오류 및 결측치

DAG는 데이터의 잘못된 측정으로 인해 발생하는 편향을 이해하는 데도 도움이 될 수 있으며, 여기에는 최악의 잘못된 측정인 전혀 측정하지 않는 것도 포함됩니다.
[Chapter -@sec-missingness]에서 이러한 주제를 다룰 것이지만, 기본 아이디어는 실제 값과 관찰된 값을 분리함으로써 그러한 편향이 어떻게 작용할 수 있는지 더 잘 이해할 수 있다는 것입니다[@Hernán2009].
다음은 *회상 편향*이라고 불리는 편향의 기본 예입니다.
회상 편향은 결과가 참가자의 노출 기억에 영향을 미치는 경우이며, 따라서 결과가 발생한 후 이전 노출이 기록될 때까지 기록되지 않는 후향적 연구에서 특히 문제입니다.
이것이 발생할 수 있는 예는 암에 대한 사례-대조 연구입니다.
암에 *걸린* 사람은 암에 걸리지 *않은* 사람보다 과거 노출에 대해 반추할 동기가 더 클 수 있습니다.
따라서 특정 노출에 대한 기억은 그렇지 않은 사람보다 더 정제될 수 있습니다.


```{r}
#| label: fig-error_dag
#| fig-width: 5.5
#| fig-height: 4
#| fig-cap: "노출 및 결과 관찰에서 측정 오류를 나타내는 DAG. 이 경우 결과는 참가자의 노출 기억에 영향을 미치며, 이를 회상 편향이라고도 합니다."
error_dag <- dagify(
  exposure_observed ~ exposure_real + exposure_error,
  outcome_observed ~ outcome_real + outcome_error,
  outcome_real ~ exposure_real,
  exposure_error ~ outcome_real,
  labels = c(
    exposure_real = "노출\n(실제)",
    exposure_error = "측정 오류\n(노출)",
    exposure_observed = "노출\n(관찰됨)",
    outcome_real = "결과\n(실제)",
    outcome_error = "측정 오류\n(결과)",
    outcome_observed = "결과\n(관찰됨)"
  ),
  exposure = "exposure_real",
  outcome = "outcome_real",
  coords = time_ordered_coords()
)

error_dag |>
  ggdag(text = FALSE, use_labels = "label")
```

## DAG 구축 권장 사항

원칙적으로 DAG를 사용하는 것은 쉽습니다. 즉, 존재한다고 생각하는 인과 관계를 지정한 다음 유효한 조정 집합과 같은 정보에 대해 DAG를 쿼리합니다.
실제로 DAG를 조립하는 데는 상당한 시간과 생각이 필요합니다.
연구 질문 자체를 정의하는 것 다음으로 인과 추론을 하는 데 있어 가장 어려운 단계 중 하나입니다.
DAG 조립에 대한 모범 사례에 대한 지침은 거의 없습니다.
@Tennant2021은 응용 건강 연구에서 DAG에 대한 데이터를 수집하여 연구자들이 이를 어떻게 사용하는지 더 잘 이해했습니다.
@tbl-dag-properties는 수집한 일부 정보를 보여줍니다. 즉, DAG의 노드 및 호의 중앙값, 비율, DAG의 포화 비율 및 완전히 포화된 DAG 수입니다.
DAG를 포화시킨다는 것은 시간 순서대로 앞으로 향하는 모든 가능한 화살표를 추가하는 것을 의미합니다. 예를 들어, 완전히 포화된 DAG에서는 시점 1의 특정 변수가 미래 시점의 모든 변수로 향하는 화살표를 갖습니다.
대부분의 DAG는 약 절반만 포화되었으며 완전히 포화된 DAG는 거의 없었습니다.

DAG를 사용한 논문의 약 절반만이 사용된 조정 집합을 보고했습니다.
즉, 연구자들은 연구 질문에 대한 가정은 제시했지만 모델링 단계를 처리하는 방법에 대한 의미나 유효한 조정 집합을 사용했는지 여부는 제시하지 않았습니다.
마찬가지로 대부분의 연구에서는 관심 있는 추정량을 보고하지 않았습니다.

::: callout-note
추정량은 [Chapter -@sec-whole-game]에서 간략하게 논의한 바와 같이 추정하려는 대상입니다.
[Chapter -@sec-estimands]에서 추정량에 대해 자세히 논의할 것입니다.
:::

```{r}
#| label: tbl-dag-properties
#| echo: false
#| message: false
#| tbl-cap: "응용 건강 연구의 DAG 속성 표. 노드 및 호 수는 분석된 DAG의 변수 및 화살표의 중앙값이며, 노드 대 호 비율은 그 비율입니다. 포화 비율은 다른 포함된 변수로 시간 순서대로 앞으로 향하는 모든 가능한 화살표의 비율입니다. 완전히 포화된 DAG는 이러한 모든 화살표를 포함하는 DAG입니다. 연구자들은 또한 연구에서 추정량과 조정 집합을 보고했는지 여부를 분석했습니다."
library(gtsummary)
library(gt)
dag_data_used <- dag_data |>
  filter(used_dag)

as_yes_no <- function(x) {
  factor(x, c(TRUE, FALSE), labels = c("예", "아니요"))
}

dag_data_used |>
  mutate(
    saturated = near(saturation, 1),
    report_adjset = report_adjset == "Yes",
    across(c(saturated, reported_estimand, report_adjset), as_yes_no)
  ) |>
  select(nodes, arcs, ratio, saturation, saturated, reported_estimand, report_adjset) |>
  tbl_summary(
    label = list(
      nodes ~ "노드 수",
      arcs ~ "호 수",
      ratio ~ "노드 대 호 비율",
      saturation ~ "포화 비율",
      saturated ~ "완전히 포화됨",
      reported_estimand ~ "보고된 추정량",
      report_adjset ~ "보고된 조정 집합"
    ),
    digits = list(everything() ~ 0, c(ratio, saturation) ~ 2),
    type = list(where(is.factor) ~ "categorical")
  ) |>
  as_gt() |>
  tab_row_group(
    label = md("**DAG 속성**"),
    rows = 1:7,
    id = "dag_prop"
  ) |>
  tab_row_group(
    label = md("**보고**"),
    rows = 8:13,
    id = "reporting"
  ) |>
  row_group_order(c("dag_prop", "reporting"))
```

이 섹션에서는 @Tennant2021의 몇 가지 조언과 DAG 조립에 대한 우리 자신의 경험을 제공할 것입니다.

### 일찍 그리고 자주 반복하기 {#sec-dags-iterate}

결과의 질을 위해 할 수 있는 가장 좋은 일 중 하나는 연구를 수행하기 전에, 이상적으로는 데이터를 수집하기 전에도 DAG를 만드는 것입니다.
이미 데이터로 작업하고 있다면 최소한 데이터 분석을 수행하기 전에 DAG를 만드십시오.
이 조언은 사전 등록된 분석 계획과 정신적으로 유사합니다. 즉, 가정을 미리 선언하면 무엇을 해야 하는지 명확히 하고, 과적합 위험을 줄이고(예: 데이터에서 교란 변수를 잘못 결정하는 것), DAG에 대한 피드백을 받을 시간을 확보하는 데 도움이 될 수 있습니다.

이 마지막 이점은 중요합니다. 이상적으로는 DAG를 민주화해야 합니다.
데이터, 영역 및 모델 전문가인 다른 사람들과 일찍 그리고 자주 공유하십시오.
DAG를 만들고 동료에게 제시한 다음 중요한 것을 놓쳤다는 것을 깨닫는 것은 당연합니다.
때로는 구조의 일부 세부 사항에 대해서만 동의할 것입니다.
그것은 좋은 일입니다. 이제 DAG에 불확실성이 어디에 있는지 알 수 있습니다.
그런 다음 여러 가지 타당한 DAG의 결과를 검토하거나 민감도 분석으로 불확실성을 해결할 수 있습니다.

후보 DAG가 두 개 이상인 경우 조정 집합을 확인하십시오.
두 DAG가 서로 동일한 조정 집합을 가지고 있다면 해당 집합에 초점을 맞추십시오. 그러면 가지고 있는 타당한 가정을 충족하는 방식으로 진행할 수 있습니다.

### 질문 고려하기

@fig-podcast_dag3에서 보았듯이 일부 질문은 특정 데이터로 답하기 어려울 수 있지만 다른 질문은 더 접근하기 쉽습니다.
정확히 무엇을 추정하고 싶은지 고려해야 합니다.
대상 추정치를 정의하는 것은 중요한 주제이며 [Chapter -@sec-estimands]의 주제입니다.

DAG가 질문과 관련된 방식에 대한 또 다른 중요한 세부 사항은 모집단과 시간입니다.
많은 인과 구조는 시간과 공간에 따라 정적이지 않습니다.
폐암을 생각해 보십시오. 흡연이 확산되기 전에는 폐암 원인의 분포가 상당히 달랐습니다.
수세기 후 아메리카 대륙에서 담배가 확산되기 전 중세 일본에서는 폐암의 인과 구조가 담배 사용 및 기타 요인(인구 연령 등) 측면에서 오늘날 일본과 실질적으로 달랐을 것입니다.

교란 변수도 마찬가지입니다.
어떤 것이 노출과 결과를 유발할 수 있더라도 분석하는 모집단에서 해당 항목의 유병률이 0이면 인과적 질문과 관련이 없습니다.
또한 일부 모집단에서는 둘 중 하나에 영향을 미치지 않을 수도 있습니다.
그 반대의 경우도 마찬가지입니다. 즉, 대상 모집단에 고유한 것이 있을 수 있습니다.
수세기 전 북미에서의 담배 사용은 의례적인 담배 사용이 현대적인 여가용 사용과 상당히 달랐음에도 불구하고 세계 인구 중에서 독특했습니다.
많은 변화가 수세기에 걸쳐 극적으로 일어나지는 않지만 때로는 규제가 한 국가에서 인구의 특정 물질에 대한 노출을 효과적으로 제거하는 경우와 같이 그렇게 발생합니다.

### 시간순으로 노드 정렬하기

앞서 논의한 바와 같이 변수를 왼쪽에서 오른쪽으로 또는 위에서 아래로 시간순으로 정렬하는 것이 좋습니다.
여기에는 두 가지 이유가 있습니다.
첫째, 시간 순서는 가정의 필수적인 부분입니다.
결국 어떤 일이 다른 일보다 먼저 일어나는 것은 그것이 원인이 되기 위한 요구 사항입니다.
이를 신중하게 생각하면 DAG와 해결해야 할 변수가 명확해집니다.

둘째, 특정 수준의 복잡성을 넘어서면 시간 차원에 대해 덜 생각해야 하므로 시간별로 정렬된 DAG를 읽기가 더 쉽습니다. 즉, 레이아웃에 내재되어 있습니다.
ggdag의 시간 순서 알고리즘은 대부분의 작업을 자동화하지만 앞서 보았듯이 순서에 대한 추가 정보를 제공하는 것이 때때로 유용합니다.

관련 주제는 피드백 루프입니다[@murray2022].
종종 우리는 지구 온난화와 에어컨 사용(에어컨 사용은 지구 온난화를 증가시켜 더 더워지고 에어컨 사용을 증가시키는 등)과 같이 서로를 상호 유발하는 두 가지를 원형으로 생각합니다.
그 관계를 다음과 같이 시각화하고 싶을 수 있습니다.

```{r}
#| label: fig-feedback-loop
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-cap: "지구 온난화로 인한 에어컨 사용과 지구 온도 간의 상호 관계를 나타내는 개념도. 피드백 루프는 시간 경과에 따라 서로 영향을 미치는 변수를 간결하게 설명하는 유용한 정신적 약칭이지만 실제 인과 다이어그램은 아닙니다."
dagify(
  ac_use ~ global_temp,
  global_temp ~ ac_use,
  labels = c(ac_use = "에어컨 사용", global_temp = "지구\n온도")
) |>
  ggdag(layout = "circle", edge_type = "arc", text = FALSE, use_labels = "label")
```

DAG 관점에서 보면 *DAG*의 *A* 부분 때문에 이것은 문제입니다. 즉, 순환적입니다!
그러나 중요한 것은 인과적 관점에서도 정확하지 않다는 것입니다.
피드백 루프는 실제로 일어나는 일에 대한 약칭이며, 두 변수가 시간 경과에 따라 *상호* 영향을 미칩니다.
인과 관계는 시간 순서대로만 진행되므로 @fig-feedback-loop에서처럼 앞뒤로 오가는 것은 의미가 없습니다.

실제 DAG는 다음과 같습니다.

```{r}
#| label: fig-feedforward
#| fig-width: 5
#| fig-height: 3.5
#| fig-cap: "시간 경과에 따른 에어컨 사용과 지구 온도 간의 관계를 보여주는 DAG. 피드백 루프의 실제 인과 관계는 *앞으로* 진행됩니다."
dagify(
  global_temp_2000 ~ ac_use_1990 + global_temp_1990,
  ac_use_2000 ~ ac_use_1990 + global_temp_1990,
  global_temp_2010 ~ ac_use_2000 + global_temp_2000,
  ac_use_2010 ~ ac_use_2000 + global_temp_2000,
  global_temp_2020 ~ ac_use_2010 + global_temp_2010,
  ac_use_2020 ~ ac_use_2010 + global_temp_2010,
  coords = time_ordered_coords(),
  labels = c(
    ac_use_1990 = "에어컨 사용\n(1990)",
    global_temp_1990 = "지구\n온도\n(1990)",
    ac_use_2000 = "에어컨 사용\n(2000)",
    global_temp_2000 = "지구\n온도\n(2000)",
    ac_use_2010 = "에어컨 사용\n(2010)",
    global_temp_2010 = "지구\n온도\n(2010)",
    ac_use_2020 = "에어컨 사용\n(2020)",
    global_temp_2020 = "지구\n온도\n(2020)"
  )
) |>
  ggdag(text = FALSE, use_labels = "label")
```

두 변수는 피드*백* 루프에 있는 것이 아니라 실제로는 피드*포워드* 루프에 있습니다. 즉, 시간 경과에 따라 함께 진화합니다.
여기서는 1990년부터 2020년까지의 10년이라는 네 가지 이산적인 시점만 보여주지만, 물론 질문과 데이터에 따라 훨씬 더 세분화할 수 있습니다.

모든 DAG와 마찬가지로 적절한 분석 접근 방식은 질문에 따라 다릅니다.
2000년 에어컨 사용이 2020년 지구 온도에 미치는 영향은 2000년 지구 온도가 2020년 에어컨 사용에 미치는 영향과 다른 조정 집합을 생성합니다.
마찬가지로 시간 경과에 따른 이 변화를 모델링할지 아니면 두 시점만 모델링할지는 질문에 따라 다릅니다.
종종 이러한 피드포워드 관계는 [Chapter -@sec-longitudinal]에서 논의할 **시간 변화 교란**을 해결해야 합니다.

### 전체 데이터 수집 과정 고려하기

@fig-podcast_dag3에서 보았듯이 질문의 인과 구조만큼이나 데이터를 수집한 *방식*을 고려하는 것이 중요합니다.
전체 데이터 수집 과정을 고려하는 것은 특히 "발견된" 데이터, 즉 연구 질문에 답하기 위해 의도적으로 수집되지 않은 데이터셋으로 작업하는 경우에 해당됩니다.
우리는 항상 가지고 있는 데이터 대 가지고 있지 않은 데이터에 대해 본질적으로 조건화하고 있습니다.
다른 변수가 인과 구조의 데이터 수집 과정에 영향을 미쳤다면 그 영향을 고려해야 합니다.
추가 변수를 통제해야 합니까?
추정하려는 효과를 변경해야 합니까?
질문에 전혀 답할 수 있습니까?

<!-- TODO: 이것에 대해 좀 더 생각해 본 후에 다시 방문하여 추가하거나 삭제합니다. -->

<!-- 예를 들어 공장 근로자가 사망 위험을 높일 수 있는 물질(예: 발암 물질)에 잠재적으로 노출되었다고 가정해 보겠습니다. 일부 근로자는 노출되었고 일부는 노출되지 않았습니다. 문제는 연구 *이전에* 노출되어 연구 시작 시점에 일할 만큼 건강한 사람만 남았다는 것입니다. 근로자의 건강에 중요한 다른 요인이 있고 그것이 또한 직장에 있는지 여부에 기여한다면 선택 편향이 있습니다. 우리는 누군가가 직장에 있는지 여부에 대해 본질적으로 계층화하고 있습니다. -->

<!-- ```{r} -->

<!-- dagify( -->

<!--     death ~ health, -->

<!--     exposed ~ exposed_prior + at_work, -->

<!--     at_work ~ exposed_prior + health, -->

<!--     exposure = "exposed", -->

<!--     outcome = "death", -->

<!--     latent = c("health", "exposed_prior"), -->

<!--     coords = time_ordered_coords(list( -->

<!--         c("health", "exposed_prior"), -->

<!--         "at_work", -->

<!-- "exposed", -->

<!--         "death" -->

<!--     )), -->

<!--     labels = c( -->

<!--         exposed_prior = "Exposed\n(prior)", -->

<!--         exposed = "Exposed\n(start)", -->

<!--         at_work = "Working", -->

<!--         health = "Health\nStatus", -->

<!--         death = "Death" -->

<!--     ) -->

<!-- ) |>  -->

<!--   ggdag(text = FALSE, use_labels = "label") -->

<!-- ``` -->

<!-- `at_work`는 충돌자입니다. 즉, 건강 상태와 이전 노출 모두 화살표가 향합니다. 이를 통제하면 ... -->

<!-- -   인종/총격 (직접 효과를 얻기 위해 `adjustmentSets`의 `effect` 인수 표시) -->

<!-- -   건강한 근로자 편향 -->

::: callout-tip
## 사례-대조 연구는 어떻습니까?

역학에서 표준 연구 설계는 사례-대조 연구입니다.
사례-대조 연구는 연구 중인 결과가 드물거나 발생하기까지 매우 오랜 시간이 걸리는 경우(예: 여러 유형의 암)에 유용합니다.
참가자는 결과에 따라 연구에 선택됩니다. 즉, 어떤 사람이 사건을 겪으면 사례로 입력되고 사건을 겪지 않은 대조군과 일치됩니다.
종종 다른 요인에 대해서도 일치됩니다.

일치된 사례-대조 연구는 설계상 선택 편향이 있습니다[@mansournia2013].
@fig-case-control에서 연구 선택에 대한 조건화를 하면 `confounder`를 통제하더라도 모든 백도어 경로를 닫는 능력을 잃게 됩니다.
DAG에서 보면 전체 설계가 유효하지 않은 것처럼 보입니다!

```{r}
#| label: fig-case-control
#| fig-width: 4.5
#| fig-height: 3.2
#| fig-cap: "일치된 사례-대조 연구를 나타내는 DAG. 이러한 연구에서 선택은 결과 상태 및 일치된 교란 변수에 의해 결정됩니다. 따라서 연구 선택은 충돌자입니다. 실제로 연구에 참여한 사람들에 대해 본질적으로 계층화되므로 이러한 데이터는 추정할 수 있는 인과 효과 유형이 제한됩니다."
dagify(
  outcome ~ confounder + exposure,
  selection ~ outcome + confounder,
  exposure ~ confounder,
  exposure = "exposure",
  outcome = "outcome",
  coords = time_ordered_coords()
) |>
  ggdag(edge_type = "arc", text_size = 2.2)
```

다행히 이것이 전부는 아닙니다.
사례-대조 연구는 추정할 수 있는 인과 효과 유형이 제한적입니다(인과적 오즈비, 일부 상황에서는 인과적 위험비를 근사함).
신중한 연구 설계와 샘플링을 통해 수학이 잘 맞아 이러한 추정치가 여전히 유효합니다.
사례-대조 연구가 정확히 어떻게 그리고 왜 작동하는지는 이 책의 범위를 벗어나지만 매우 영리한 설계입니다.
:::

### 가지고 있지 않은 변수 포함하기

인과 구조에 중요한 *모든* 변수를 포함하는 것이 중요하며, 데이터에서 측정한 변수만 포함하는 것이 아닙니다.
ggdag는 변수를 측정되지 않은("잠재적") 것으로 표시할 수 있습니다. 그러면 측정되지 않은 변수가 없는 사용 가능한 조정 집합만 반환합니다.
물론 가장 좋은 방법은 DAG를 사용하여 애초에 무엇을 측정해야 하는지 이해하는 데 도움을 받는 것이지만, 데이터가 다를 수 있는 여러 가지 이유가 있습니다.
연구 질문을 위해 의도적으로 수집된 데이터조차도 데이터 수집 후 교란 변수로 발견된 변수가 없을 수 있습니다.

예를 들어, `exposure`와 `outcome`이 `confounder1`과 `confounder2`로 구성된 교란 경로를 갖는 DAG가 있는 경우 둘 중 하나를 통제하여 추정치를 성공적으로 편향 제거할 수 있습니다.

```{r}
dagify(
  outcome ~ exposure + confounder1,
  exposure ~ confounder2,
  confounder2 ~ confounder1,
  exposure = "exposure",
  outcome = "outcome"
) |>
  adjustmentSets()
```

따라서 하나만 누락된 경우(`latent`) 괜찮습니다.

```{r}
dagify(
  outcome ~ exposure + confounder1,
  exposure ~ confounder2,
  confounder2 ~ confounder1,
  exposure = "exposure",
  outcome = "outcome",
  latent = "confounder1"
) |>
  adjustmentSets()
```

그러나 둘 다 누락된 경우 유효한 조정 집합이 없습니다.

측정된 변수가 없는 경우에도 몇 가지 옵션이 있습니다.
위에서 언급했듯이 대체 조정 집합을 식별할 수 있습니다.
누락된 변수가 모든 백도어 경로를 완전히 닫는 데 필요한 경우 해당 변수가 없는 것의 영향을 이해하기 위해 민감도 분석을 수행해야 합니다.
이것은 [Chapter -@sec-sensitivity]의 주제입니다.

운이 좋은 일부 상황에서는 *대리* 교란 변수를 사용할 수도 있습니다[@miao2018].
대리 교란 변수는 교란 변수와 밀접하게 관련된 변수이므로 이를 통제하면 누락된 변수의 일부 효과를 통제합니다.
`q`가 원인 `p`를 갖는 기본 교란 관계의 확장을 고려해 보십시오(@fig-proxy-confounder).
기술적으로 `q`가 없으면 백도어 경로를 닫을 수 없으며 효과는 편향됩니다.
그러나 실제로는 `p`가 `q`와 고도로 상관 관계가 있다면 `q`에서 오는 교란을 줄이는 방법으로 사용될 수 있습니다.
`p`를 `q`의 잘못 측정된 버전으로 생각할 수 있습니다. `q`를 통한 편향을 완전히 통제하지는 못하지만 최소화하는 데 도움이 될 수 있습니다.

```{r}
#| label: fig-proxy-confounder
#| fig-width: 4.5
#| fig-height: 3.2
#| fig-cap: "교란 변수 `q`와 대리 교란 변수 `p`가 있는 DAG. 실제 조정 집합은 `q`입니다. `p`가 `q`를 유발하므로 `q`에 대한 정보를 포함하며 `q`를 측정하지 않은 경우 편향을 줄일 수 있습니다."
dagify(
  y ~ x + q,
  x ~ q,
  q ~ p,
  coords = time_ordered_coords()
) |>
  ggdag(edge_type = "arc")
```

### DAG 포화 후 가지치기하기

@tbl-dag-properties를 논의하면서 *포화된* DAG를 언급했습니다.
이는 시간 순서에 따라 가능한 모든 화살표가 포함된 DAG입니다. 예를 들어, 모든 변수는 시간상 그 뒤에 오는 변수를 유발합니다.

화살표를 포함하지 *않는 것*은 포함하는 것보다 더 큰 가정입니다.
즉, 기본값은 한 변수에서 미래 변수로 향하는 화살표를 갖는 것입니다.
이 기본값은 많은 사람들에게 직관에 어긋납니다.
인과 효과를 평가하는 데 그렇게 신중해야 하는데 DAG에서 인과적 가정을 적용하는 데 그렇게 자유로울 수 있을까요?
이에 대한 답은 원인의 강도와 유병률에 있습니다.
기술적으로 화살표가 있다는 것은 *적어도 하나의 관찰에 대해* 이전 노드가 다음 노드를 유발한다는 것을 의미합니다.
마찬가지로 화살표는 관계의 강도에 대해 아무것도 말하지 않습니다.
따라서 단일 개인에 대한 아주 작은 인과 효과는 화살표의 존재를 정당화합니다.
실제로 그러한 경우는 아마도 관련이 없을 것입니다.
*사실상* 화살표가 없습니다.

::: {.callout-note}
다시 말해, 이 가정은 연구 중인 단위 중 적어도 하나가 개별적인 인과 효과를 갖는다고 말하는 것입니다. `X`에서 `Y`로 이어지는 화살표가 있는 변수 `X`가 있다면, 적어도 한 사람에 대해 연구 중인 `X` 값에 대해 잠재적 결과 `Y(X = x)`에 변화가 있다고 말하는 것입니다. @tbl-po의 관점에서 보면, 모든 개인에 대해 `y_chocolate - y_vanilla`는 0이 될 것입니다.

연구 중인 단위 중 단 하나도 개별적인 인과 효과를 갖지 않는 경우를 **날카로운 귀무 가설**이라고 합니다.
:::

그러나 더 중요한 점은 화살표를 추가하는 데 자신감을 가져야 한다는 것입니다.
정당화의 기준은 생각보다 훨씬 낮습니다.
대신 1) 시간 순서를 결정하고, 2) DAG를 포화시키고, 3) 타당하지 않은 화살표를 가지치기하는 것이 유용합니다.

팟캐스트-시험 DAG의 포화된 버전을 통해 실험해 보겠습니다.

먼저 시간 순서입니다.
아마도 학생의 유머 감각은 시험 당일보다 훨씬 이전에 형성되었을 것입니다.
아침의 기분도 팟캐스트를 듣거나 시험 점수를 받기 전에 발생하며, 준비도 마찬가지입니다.
이 순서가 주어졌을 때 포화된 DAG는 다음과 같습니다.

```{r}
#| label: fig-podcast_dag_sat
#| fig-width: 5.5
#| fig-height: 4
#| code-fold: true
#| fig-cap: "`podcast_dag`의 포화된 버전: 변수는 시간 경과에 따라 다른 변수로 향하는 모든 가능한 화살표를 갖습니다."
podcast_dag_sat <- dagify(
  podcast ~ mood + humor + prepared,
  exam ~ mood + prepared + humor,
  prepared ~ humor,
  mood ~ humor,
  coords = time_ordered_coords(
    list(
      "humor",
      c("prepared", "mood"),
      "podcast",
      "exam"
    )
  ),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    mood = "기분",
    humor = "유머",
    prepared = "준비됨"
  )
)

curvatures <- rep(0, 8)
curvatures[1] <- .25

podcast_dag_sat |>
  tidy_dagitty() |>
  ggplot(aes(x, y, xend = xend, yend = yend)) +
  geom_dag_point() +
  geom_dag_edges_arc(curvature = curvatures) +
  geom_dag_label_repel()
```

여기에 몇 가지 새로운 화살표가 있습니다.
유머는 이제 다른 두 교란 변수와 시험 점수도 유발합니다.
그중 일부는 의미가 있습니다.
유머 감각은 일부 사람들의 기분에 영향을 미칠 수 있습니다.
준비는 어떻습니까?
이 관계는 약간 덜 타당해 보입니다.
마찬가지로 채점이 맹검이기 때문에 유머 감각이 이 경우 시험 점수에 영향을 미치지 않는다는 것을 알고 있습니다.
그 두 가지를 가지치기하겠습니다.

```{r}
#| label: fig-podcast_dag_pruned
#| code-fold: true
#| fig-width: 5.5
#| fig-height: 4
#| fig-cap: "@fig-podcast_dag_sat의 가지치기된 버전: 완전히 포화된 DAG에서 타당하지 않은 화살표를 제거했습니다."
podcast_dag_pruned <- dagify(
  podcast ~ mood + humor + prepared,
  exam ~ mood + prepared,
  mood ~ humor,
  coords = time_ordered_coords(
    list(
      "humor",
      c("prepared", "mood"),
      "podcast",
      "exam"
    )
  ),
  exposure = "podcast",
  outcome = "exam",
  labels = c(
    podcast = "팟캐스트",
    exam = "시험 점수",
    mood = "기분",
    humor = "유머",
    prepared = "준비됨"
  )
)

ggdag(podcast_dag_pruned, text = FALSE, use_labels = "label")
```

이 DAG는 더 합리적으로 보입니다.
그렇다면 원래 DAG가 틀렸을까요?
그것은 여러 요인에 따라 다릅니다.
특히 두 DAG 모두 동일한 조정 집합을 생성합니다. 즉, `mood`와 `prepared`를 통제하면 두 DAG 중 하나가 정확하다면 편향되지 않은 효과를 얻을 수 있습니다.
새로운 DAG가 다른 조정 집합을 생성하더라도 결과가 의미 있게 다른지 여부는 교란의 강도에 따라 다릅니다.

### 도구 및 정밀 변수 포함하기

기술적으로 DAG에 도구 및 정밀 변수를 포함할 필요는 없습니다.
조정 집합은 있든 없든 동일합니다.
그러나 이를 추가하는 것은 두 가지 이유로 유용합니다.
첫째, 관계와 연구 중인 변수에 대한 가정을 보여줍니다.
위에서 논의한 바와 같이 화살표를 포함하지 *않는 것*은 포함하는 것보다 더 중요한 가정이므로 인과 구조가 어떻게 작동한다고 생각하는지에 대한 귀중한 정보입니다.
둘째, 모델링 결정에 영향을 미칩니다.
추정치의 변동성을 줄이기 위해 항상 모델에 정밀 변수를 포함해야 하므로 이를 식별하는 데 도움이 됩니다.
도구는 @sec-evidence에서 논의할 것처럼 대체 또는 보완적인 모델링 전략을 안내할 수 있기 때문에 보는 것도 유용합니다.

### 인과 구조에 초점 맞춘 후 측정 편향 고려하기

위에서 보았듯이 결측치와 측정 오류는 편향의 원인이 될 수 있습니다.
[Chapter -@sec-missingness]에서 보게 되겠지만, 이러한 상황에 접근하는 여러 가지 전략이 있습니다.
그러나 우리가 측정하는 거의 모든 것은 어느 정도 부정확합니다.
당면한 데이터에 대한 실제 DAG는 본질적으로 변수의 측정된 버전에 대해 조건화합니다.
그런 의미에서 데이터는 항상 미묘하게 잘못되었으며, 일종의 신뢰할 수 없는 화자입니다.
언제 이 정보를 DAG에 포함해야 할까요?
각 변수를 완벽하게 측정했다고 가정하고 먼저 DAG의 인과 구조에 초점을 맞추는 것이 좋습니다[@hernan2021].
그런 다음 잘못된 측정과 결측치가 실현된 데이터, 특히 노출, 결과 및 중요한 교란 변수와 관련하여 어떻게 영향을 미칠 수 있는지 고려하십시오.
이러한 출처에서 발생하는 편향을 해결하기 위한 전략(예: 대체 또는 민감도 분석)을 고려하기 위해 이를 대체 DAG로 제시하는 것을 선호할 수 있습니다.
결국 @fig-error_dag의 DAG는 모든 백도어 경로를 닫을 방법이 없기 때문에 질문에 답할 수 없다고 생각하게 만듭니다.
모든 열린 경로와 마찬가지로 이는 편향의 심각성과 이를 해결하는 능력에 따라 달라집니다.

<!-- TODO: 여기서 무엇을 다루고 싶었는지 잘 기억나지 않으므로 나중에 다시 방문하여 추가하거나 삭제합니다. -->

<!-- ### 정확하되 명확성에 초점 맞추기 -->

### 성공 가능성이 가장 높은 조정 집합 선택하기

측정 오류가 중요한 고려 사항인 한 가지 영역은 조정 집합을 선택할 때입니다.
이론적으로 DAG가 정확하다면 모든 조정 집합이 편향되지 않은 결과를 생성하는 데 작동합니다.
실제로 변수는 품질 수준이 다릅니다.
정확한 변수를 포함하기 때문에 성공 가능성이 가장 높은 조정 집합을 선택하십시오.
마찬가지로 비최소 조정 집합은 백도어 경로를 따라 측정 오류가 있는 여러 변수가 함께 해당 경로에서 발생하는 실제 편향을 최소화하기에 충분할 수 있으므로 고려하는 것이 유용합니다.

특정 중요한 변수를 측정하지 않아 유효한 조정 집합이 없다면 어떻게 될까요?
이 경우 다른 백도어 경로에서 편향을 최소화할 가능성이 가장 높은 조정 집합을 선택해야 합니다.
모든 교란 변수를 측정하지 않았다고 해서 모든 것이 끝난 것은 아닙니다. 즉, 가능한 한 최고 품질의 추정치를 얻은 다음 측정되지 않은 변수에 대한 민감도 분석을 수행하여 영향을 이해하십시오.

### 견고성 검사 사용하기

마지막으로 DAG의 견고성을 확인하는 것이 좋습니다.
대부분의 조건에서 DAG의 정확성을 확인할 수는 없지만 DAG의 의미를 사용하여 이를 뒷받침할 수 있습니다.
상황에 따라 유용할 수 있는 세 가지 유형의 견고성 검사가 있습니다.

1.  **음성 대조군** [@Lipsitch2010]. 음성 노출 대조군과 음성 결과 대조군의 두 가지 유형이 있습니다. 아이디어는 하나와는 연관되지만 다른 하나와는 연관되지 않은 것, 예를 들어 결과와는 연관되지만 노출과는 연관되지 않은 것을 찾는 것입니다. 따라서 효과가 없어야 합니다. 효과가 없어야 하므로 이제 *다른* 효과(예: 귀무 가설과의 차이)를 얼마나 잘 통제하는지에 대한 측정이 있습니다. 이상적으로 음성 대조군의 교란 변수는 연구 질문과 유사해야 합니다.
2.  **DAG-데이터 일관성** [@Textor2016]. 음성 대조군은 DAG의 의미입니다. 이 아이디어의 확장은 그러한 의미가 *많이* 있다는 것입니다. 경로를 차단하면 해당 경로에서 통계적 종속성이 제거되므로 DAG의 여러 위치에서 이러한 가정을 확인할 수 있습니다.
3.  **대체 조정 집합**. 조정 집합은 무작위 및 측정 오류를 제외하고 모두 백도어 경로를 차단하는 집합이므로 대략 동일한 답을 제공해야 합니다. 둘 이상의 조정 집합이 합리적으로 보이면 여러 모델을 확인하여 민감도 분석으로 사용할 수 있습니다.

[Chapter -@sec-sensitivity]에서 이에 대해 자세히 논의할 것입니다.
여기서 주의할 점은 이것이 초기 DAG를 보완해야 하며 *대체*하는 방법이 아니라는 것입니다.
실제로 분석 중에 둘 이상의 조정 집합을 사용하는 경우 데이터에 결과를 과적합하는 것을 피하기 위해 모든 결과를 보고해야 합니다.
